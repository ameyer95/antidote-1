\section{Abstract Semantics}

Additionally, we provide semantics for calculations on our abstraction $\langle T, n \rangle$,
given in Figure~\ref{fig:abstract}.
Here, the state is a triple $(\langle T, n \rangle, \Phi', p^\#)$
where $\Phi' \subseteq \Phi \cup \{\bot\}$
(because now, since there are multiple possible training sets,
multiple different $\varphi \in \Phi$ could be the best split,
and $\bot$ is for the all-trivial-split possibility)
and where $p^\# \in 2^{[0,1]}$
using some appropriate abstract domain, e.g.\ intervals.
Now, $\den{P}^\# : \langle T, n \rangle \mapsto p^\#$.
Let me point out a few (but not all) details
that introduce imprecision through overapproximations:
\begin{itemize}
    \item In the branching based on $\mathit{impurity}(T) = 0$,
        no refinement of $\mathit{impurity}(T)$ is done when taking the else-branch;
        this is because the dropout domain, as presented,
        is not in general capable of more-tightly expressing an upper bound for
        $\alpha(\{T' \in \langle T, n \rangle \mid \mathit{impurity}(T') \neq 0\})
        \sqsubseteq \langle T, n \rangle$.
    \item When updating the state via
        $\den{\varphi \gets \mathit{bestsplit}_\Phi(T)}^\#$,
        certain $\varphi$ could only be the best split for specific $T' \in \langle T, n \rangle$,
        yet all are incorporated into the single unified abstraction.
        Accordingly, anywhere different dropout sets are joined,
        if their symmetric difference is large, the resultant join
        will be very imprecise.
        (In particular, this happens in $\den{T \gets \mathit{filter}(T, \varphi)}^\#$,
        especially when there exist very extensionally different $\varphi, \psi \in \Phi'$,
        or when $\Phi'$ is simply large.)
    \item When selecting the best split, there is the potential for large overapproximations:
        \rone we completely ignore tie-breaking via $<_\Phi$, and (more importantly)
        \rtwo we are not able to track joint information about when certain $\varphi$
        are trivial splits for some $T'$ and not others.
    \item Filtering can produce $\langle T, n \rangle$ with $n = |T|$ (i.e.\ $\emptyset \in \langle T, n \rangle$),
        but we know that if $\varphi$ is bound through selecting a best split,
        in the concrete case, we would never do that if the resultant filter call would equal $\emptyset$.
        The grammar is not strong enough to actaully enforce this, however,
        so instead we allow for $\mathit{summary^\#}(\langle T, n \rangle)$
        to return $\top$ (i.e.\ $[0, 1]$) whenever $n = |T|$ --
        since in the concrete case, we avoid defining $\mathit{summary}$ for $|T| = 0$
        and instead have as an invariant of the semantics that an initially non-empty training set
        will never encounter it.
\end{itemize}

\begin{figure}
\centering
\newcommand{\argtuple}{\langle T, n \rangle, \Phi', p^\#}
\begin{align*}
\den[P]{S ; R}^\#(\langle T, n \rangle) \coloneqq&~
\den[R]{R}^\#(\den[S]{S}^\#(\langle T, n \rangle, \bot, \bot)) \\
%
\den[S]{S_1 ; S_2}^\#(\argtuple) \coloneqq&~
\den[S]{S_2}^\#(\den[S]{S_1}^\#(\argtuple)) \\
%
\den[S]{\iteimpuritynode{S_1}{S_2}}^\#(\argtuple) \coloneqq&~
\text{let } T_0^\# = \mathit{puresets}(\langle T, n \rangle, 0) \text{ and }
T_1^\# = \mathit{puresets}(\langle T, n \rangle, 1) \text{ in } \\
&~\den[S]{S_2}^\#(\langle T, n \rangle, \Phi', p^\#) \\
&~\sqcup
(\text{if } T_0^\# = \bot \text{ then } \bot \text{ else } \den[S]{S_1}^\#(T_0^\#, \Phi', p^\#)) \\
&~\sqcup
(\text{if } T_1^\# = \bot \text{ then } \bot \text{ else } \den[S]{S_1}^\#(T_1^\#, \Phi', p^\#)) \\
%
\den[S]{\itetrivialnode{S}{U}}^\#(\argtuple) \coloneqq&~
(\text{if } \bot \in \Phi' \text{ then } \den[S]{S}^\#(\langle T, n \rangle, \{\bot\}, p^\#) \text{ else } \bot) \\
&~\sqcup
(\text{if } \Phi' \setminus \{\bot\} \neq \emptyset \text{ then }
\den[U]{U}^\#(\langle T, n \rangle, \Phi' \setminus \{\bot\}, p^\#) \text{ else } \bot)\\
%
\den[S]{\bestsplitnode}^\#(\argtuple)
\coloneqq&~ (\langle T, n \rangle, \mathit{bestsplit}_\Phi^\#(\langle T, n \rangle), p^\#) \\
%
\den[S]{\summarynode}^\#(\argtuple) \coloneqq&~
(\langle T, n \rangle, \Phi', \mathit{summary}^\#(\langle T, n \rangle)) \\
%
\den[U]{U ; S}^\#(\argtuple) \coloneqq&~
\den[S]{S}^\#(\den[U]{U}^\#(\argtuple)) \\
%
\den[U]{\itemodelsnode{U_1}{U_2}}^\#(\argtuple) \coloneqq&~
\text{let } \Psi = \{\varphi \in \Phi' : x \models \varphi\} \text{ in } \\
&~(\text{if } \Psi = \emptyset \text{ then } \bot \text{ else }
\den[U]{U_1}^\#(\langle T, n \rangle, \Psi, p^\#)) \\
&~\sqcup
(\text{if } \Phi' \setminus \Psi = \emptyset \text{ then } \bot \text{ else }
\den[U]{U_2}^\#(\langle T, n \rangle, \Phi' \setminus \Psi, p^\#)) \\
%
\den[U]{\filternode[(\lnot)]}^\#(\argtuple) \coloneqq&~
(\bigsqcup_{\varphi \in \Phi'} (\langle T, n \rangle \upharpoonright (\lnot) \varphi), \Phi', p^\#) \\
%
\den[R]{\returnnode}^\#(\argtuple) \coloneqq&~ p^\#
\end{align*}
where
\begin{align*}
(\langle T_1, n_1 \rangle, \Phi_1', p_1^\#) \sqcup (\langle T_2, n_2 \rangle, \Phi_2', p_2^\#)
\coloneqq&~
(\langle T_1, n_1 \rangle \sqcup \langle T_2, n_2 \rangle,
\Phi_1' \cup \Phi_2', p_1^\# \sqcup p_2^\#) \\
%
T \upharpoonright \varphi \coloneqq&~ \{(x,y) \in T \mid x \models \varphi\} \\
%
\langle T, n \rangle \upharpoonright \varphi \coloneqq&~
\langle T \upharpoonright \varphi, \text{min}(n, |T \upharpoonright \varphi|) \rangle \\
%
\mathit{puresets}(\langle T, n\rangle, \hat{y}) \coloneqq&~
\text{let } T' = \{(x,y) \in T \mid y = \hat{y}\} \text{ in }
\text{if } |T \setminus T'| \leq n \text{ then } \langle T', n - |T \setminus T'| \rangle
\text{ else } \bot \\
%
\mathit{summary}^\#(\langle T, n \rangle) \coloneqq&~
\text{if } n = |T| \text{ then } [0, 1] \text{ else }
\text{let } c_1 = |\{(x,y) \in T : y = 1\}| \text{ in }
\frac{[max(0, c_1 - n), c_1]}{[|T| - n, |T|]}\\
%
\mathit{impurity}^\#(\langle T, n \rangle) \coloneqq&~
[2,2] \cdot \mathit{summary^\#(\langle T, n \rangle)}
\cdot ([1,1] - summary^\#(\langle T, n \rangle)) \\
%
\mathit{score}^\#(\langle T, n \rangle, \varphi) \coloneqq&~
\text{let } \langle T_0, n_0 \rangle = \langle T, n \rangle \upharpoonright \lnot \varphi
\text{ and } \langle T_1, n_1 \rangle = \langle T, n \rangle \upharpoonright \varphi \text{ in } \\
&~[|T_0| - n_0, |T_0|] \cdot \mathit{impurity}^\#(\langle T_0, n_0 \rangle) +
[|T_1| - n_1, |T_1|] \cdot \mathit{impurity}^\#(\langle T_1, n_1 \rangle)\\
%
\mathit{bestsplit}^\#_\Phi(\langle T, n \rangle) \coloneqq&~
\text{let } \Psi_\forall = \{\varphi \in \Phi : \emptyset \not \in \langle T, n \rangle \upharpoonright \varphi
\land \emptyset \not \in \langle T, n \rangle \upharpoonright \lnot\varphi\} \text{ in } \\
&~\text{let } \Psi_\exists = \{\varphi \in \Phi :
\langle \emptyset, \cdot \rangle \neq \langle T, n \rangle \upharpoonright \varphi \land
\langle \emptyset, \cdot \rangle \neq \langle T, n \rangle \upharpoonright \lnot \varphi \} \text{ in } \\
&~\text{if } \Psi_\forall = \emptyset \text{ then } \Psi_\exists \cup \{\bot\} \\
&~\text{else } \{\varphi \in \Psi_\exists : \min(\mathit{score}^\#(\langle T, n \rangle, \varphi))
\leq \min_{\varphi^* \in \Psi_\forall} \max(\mathit{score}^\#(\langle T, n \rangle, \varphi^*))\}
\end{align*}
\caption{Dropout Semantics (note that many of the auxiliary functions involve interval arithmetic).}
\label{fig:abstract}
\end{figure}


Again, we have that $\bot \not \in \Phi'$ when we need to use it.
\begin{proposition}[todo]
\todo{Write the analog of the concrete one}
\end{proposition}

And, perhaps most importantly, the semantics are sound.
There are a lot of details, many of which are fairly trivial.
We will highlight the main non-trivial detail with a lemma:
\begin{lemma}
Fix a set of predicates $\Phi$, a training set $T$, and an integer $n \leq |T|$.
Let $C = \{\mathit{bestsplit}_\Phi(T') : T' \in \langle T, n \rangle\}$
and let $A = \mathit{bestsplit}^\#_\Phi(\langle T, n \rangle)$;
then $C \subseteq A$.
\end{lemma}
\begin{proof}
Intuitively, in $\mathit{bestsplit}^\#_\Phi$ the set of predicates
$\Psi_\forall$ consists of those $\varphi \in \Phi$
such that \emph{for all} possible $T' \in \langle T, n \rangle$,
$\varphi$ non-trivially splits $T'$;
$\Psi_\exists$ similarly contains those $\varphi \in \Phi$
such that \emph{there exists} some $T' \in \langle T, n \rangle$
which $\varphi$ non-trivially splits.
These are used to reason (imprecisely) about
\rone what score a predicate needs to have the potential to be the best split, and
\rtwo whether it's possible that, for some $T'$, \emph{only} trivial splits are possible.
We will show $C \subseteq A$ by showing each $\hat{\varphi}$ in $C$ must also be in $A$.
We proceed through two cases:
\begin{itemize}
    \item Case $\hat{\varphi} = \bot$:
        then by definition of $C$, there exists some $T' \in \langle T, n \rangle$
        such that in the computation of $\mathit{bestsplit}_\Phi(T')$,
        all $\varphi \in \Phi$ resulted in trivial splits.
        Accordingly, since for each $\varphi$ there exists some $T'$ (the one fixed prior)
        that is split trivially, in the computation of
        $\mathit{bestsplit}^\#_\Phi(\langle T, n \rangle)$
        we have that $\Psi_\forall = \emptyset$,
        and the if-then-else expression thus returns $\bot$ (among other things).
    \item Case $\hat{\varphi} \neq \bot$:
        there exists some $T' \in \langle T, n \rangle$
        such that in the computation of $\mathit{bestsplit}_\Phi(T')$,
        \rone $\hat{\varphi}$ non-trivally splits $T'$, and furthermore
        \rtwo for all $\varphi \in \Phi'$ we have that
        $\mathit{score}(T', \hat{\varphi}) \leq \mathit{score}(T', \varphi)$.
        Using \rone we have that in the computation of $\mathit{bestsplit}^\#_\Phi(\langle T, n \rangle)$,
        $\hat{\varphi} \in \Psi_\exists$.
        Thus if $\Psi_\forall = \emptyset$, we have that $\hat{\varphi}$ is included in $A$;
        otherwise, consider the minimizing $\varphi^*$ in the last line of $\mathit{bestsplit}^\#_\Phi$,
        and by employing \rtwo observe that $\mathit{score}(T', \hat{\varphi}) \leq \mathit{score}(T', \varphi^*)$,
        thus certainly $\min(\mathit{score}^\#(\langle T, n \rangle, \hat{\varphi})) \leq
        \max(\mathit{score}^\#(\langle T, n \rangle, \varphi^*))$,
        and we still have that $\hat{\varphi}$ is included in $A$.
\end{itemize}
\end{proof}
\begin{theorem}[Soundness]
If $T' \in \langle T, n \rangle$ then $\den{P}(T') \in \den{P}^\#(\langle T, n \rangle)$.
\end{theorem}
\begin{proof}
``Trivial,'' ``obvious,'' etc., following induction over the grammar.
\end{proof}



\subsection{More General Abstract Semantics}

Here we will be more general.
Since the concrete semantics manipulate a state triple $\sigma = (T, \varphi, p)$
where $T \in \mathcal{T}$, $\varphi \in \Phi \cup \{ \bot \}$, and $p \in D$,
the abstract semantics will manipulate some abstract state $\sigma^\#$
that is an element in an abstract domain $\mathcal{L}$.
Each abstract element represents some set of concrete elements:
we have the concretization function
$\gamma : \mathcal{L} \rightarrow 2^{\mathcal{T} \times (\Phi \cup \{\bot\}) \times D}$.

We will require that the abstract domain over the program state
support abstract transformers that correspond to the expressions
in the tree-learning-classification DSL,
as well as some particular meets-with-abstractions-of-general-sets.
Given these, we can present abstract semantics for the DSL in more generality
as in Figure~\ref{fig:abstractgeneral}.

\begin{figure}
\centering
\begin{align*}
\den[P]{S ; R}^\#(\mathcal{T}') \coloneqq&~
\den[R]{R}^\#(\den[S]{S}^\#(\alpha(\mathcal{T}' \times \emptyset \times \emptyset))) \\
%
\den[S]{S_1 ; S_2}^\#(\sigma^\#) \coloneqq&~
\den[S]{S_2}^\#(\den[S]{S_1}^\#(\sigma^\#)) \\
%
\den[S]{\iteimpuritynode{S_1}{S_2}}^\#(\sigma^\#) \coloneqq&~
\den[S]{S_1}^\#(\sigma^\# \sqcap \alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) = 0\} \times (\Phi \cup \{\bot\}) \times D)) \\
&~\sqcup
\den[S]{S_2}^\#(\sigma^\# \sqcap \alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) \neq 0\} \times (\Phi \cup \{\bot\}) \times D)) \\
%
\den[S]{\itetrivialnode{S}{U}}^\#(\sigma^\#) \coloneqq&~
\den[S]{S}^\#(\sigma^\# \sqcap \alpha(\mathcal{T} \times \{\bot\} \times D))
\sqcup
\den[U]{U}^\#(\sigma^\# \sqcap \alpha(\mathcal{T} \times \Phi \times D)) \\
%
\den[S]{\bestsplitnode}^\#(\sigma^\#) \coloneqq&~
\mathit{applybestsplit}(\sigma^\#) \\
%
\den[S]{\summarynode}^\#(\sigma^\#) \coloneqq&~
\mathit{applysummary}(\sigma^\#) \\
%
\den[U]{U ; S}^\#(\sigma^\#) \coloneqq&~
\den[S]{S}^\#(\den[U]{U}^\#(\sigma^\#)) \\
%
\den[U]{\itemodelsnode{U_1}{U_2}}^\#(\sigma^\#) \coloneqq&~
\den[U]{U_1}^\#(\sigma^\# \sqcap \alpha(\mathcal{T} \times \{\varphi \in \Phi : x \models \varphi\} \times D)) \\
&~\sqcup
\den[U]{U_2}^\#(\sigma^\# \sqcap \alpha(\mathcal{T} \times \{\varphi \in \Phi : x \not\models \varphi\} \times D)) \\
%
\den[U]{\filternode[(\lnot)]}^\#(\sigma^\#) \coloneqq&~
\mathit{applyfilter}_{(\lnot)}(\sigma^\#) \\
%
\den[R]{\returnnode}^\#(\sigma^\#) \coloneqq&~
\pi_D(\gamma(\sigma^\#))
\end{align*}
\caption{General Abstract Semantics.}
\label{fig:abstractgeneral}
\end{figure}

Accordingly, a given abstract domain $\mathcal{L}$ must implement the following operations:
\begin{itemize}
    \item $\lambda \sigma^\# \ldotp \sigma^\# \sqcap
        \alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) = 0\} \times (\Phi \cup \{\bot\}) \times D)$,
        which should (leave the predicates and posteriors unchanged and)
        try to restrict the possible training sets to those that are ``pure.''
    \item $\lambda \sigma^\# \ldotp \sigma^\# \sqcap
        \alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) \neq 0\} \times (\Phi \cup \{\bot\}) \times D)$,
        which does similarly for mixed-classification training sets.
    \item $\lambda \sigma^\# \ldotp \sigma^\# \sqcap
        \alpha(\mathcal{T} \times \{\bot\} \times D)$,
        which removes all instances of predicates other the bottom element
        (for descending into the $\varphi = \bot$ if-then-else case).
    \item $\lambda \sigma^\# \ldotp \sigma^\# \sqcap
        \alpha(\mathcal{T} \times \Phi \times D)$,
        which keeps only the non-bottom-element predicates.
    \item $\lambda \sigma^\# \ldotp \sigma^\# \sqcap
        \alpha(\mathcal{T} \times \{\varphi \in \Phi : x \models \varphi\} \times D)$,
        which removes all states in which the predicate does not have $x \models \varphi$.
    \item $\lambda \sigma^\# \ldotp \sigma^\# \sqcap
        \alpha(\mathcal{T} \times \{\varphi \in \Phi : x \not\models \varphi\} \times D)$,
        which behaves similarly for $x \not\models \varphi$.
    \item $\mathit{applybestsplit}(\sigma^\#)$,
        which updates the predicate portion of the represented states
        to correspond to the possible best-splitting-predicate
        based on the possible training sets.
    \item $\mathit{applysummary}(\sigma^\#)$,
        which updates the posterior portion of the represented states
        to correspond to the possible summaries
        based on the possible training sets.
    \item $\mathit{applyfilter}_{(\lnot)}(\sigma^\#)$,
        which updates the training set portion of the represented states
        to correspond to the remainder that satisfy the predicate portion
        (or $\lnot$ of the predicate portion).
\end{itemize}

One such abstract domain could be ``boxes'' formed from abstract domains
over each individual element of the state tuple:
if we have some abstractions $T^\#$, $\varphi^\#$, and $p^\#$,
then we could consider a $\sigma^\# = (T^\#, \varphi^\#, p^\#)$.
Given any suitable abstract domain for states $\mathcal{L}$,
we can use bounded disjuncts (and a greedy joining strategy)
to form a more precise abstract domain $\mathcal{L}_k$
(whose elements are comprised of at most $k$ elements in $\mathcal{L}$).
We'll introduce these one at a time.

\begin{figure}
\centering
Where $\sigma^\# = (T^\#, \varphi^\#, p^\#)$,
\begin{align*}
\lambda \sigma^\# \ldotp \sigma^\# \sqcap
\alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) = 0\} \times (\Phi \cup \{\bot\}) \times D)
\coloneqq&~
(T^\# \sqcap_\mathcal{T} \alpha_\mathcal{T}(\{T \in \mathcal{T} : \mathit{impurity}(T) = 0\}),
\varphi^\#, p^\#) \\
%
\lambda \sigma^\# \ldotp \sigma^\# \sqcap
\alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) \neq 0\} \times (\Phi \cup \{\bot\}) \times D)
\coloneqq&~
(T^\# \sqcap_\mathcal{T} \alpha_\mathcal{T}(\{T \in \mathcal{T} : \mathit{impurity}(T) \neq 0\}),
\varphi^\#, p^\#) \\
%
\lambda \sigma^\# \ldotp \sigma^\# \sqcap
\alpha(\mathcal{T} \times \{\bot\} \times D)
\coloneqq&~
(T^\#, \alpha_{\Phi\cup\{\bot\}}(\{\bot\}), p^\#) \\
%
\lambda \sigma^\# \ldotp \sigma^\# \sqcap
\alpha(\mathcal{T} \times \Phi \times D)
\coloneqq&~
(T^\#, \alpha_{\Phi\cup\{\bot\}}(\Phi), p^\#) \\
%
\lambda \sigma^\# \ldotp \sigma^\# \sqcap
\alpha(\mathcal{T} \times \{\varphi \in \Phi : x \models \varphi\} \times D)
\coloneqq&~
(T^\#, \varphi^\# \sqcap_{\Phi\cup\{\bot\}}
\alpha_{\Phi\cup\{\bot\}}(\{\varphi \in \Phi : x \models \varphi\}), p^\#) \\
%
\lambda \sigma^\# \ldotp \sigma^\# \sqcap
\alpha(\mathcal{T} \times \{\varphi \in \Phi : x \not\models \varphi\} \times D)
\coloneqq&~
(T^\#, \varphi^\# \sqcap_{\Phi\cup\{\bot\}}
\alpha_{\Phi\cup\{\bot\}}(\{\varphi \in \Phi : x \not\models \varphi\}), p^\#) \\
%
\mathit{applybestsplit}(\sigma^\#)
\coloneqq&~
(T^\#, \mathit{bestsplit}^\#_\Phi(T^\#), p^\#) \\
%
\mathit{applysummary}(\sigma^\#)
\coloneqq&~
(T^\#, \varphi^\#, \mathit{summary}^\#(T^\#)) \\
%
\mathit{applyfilter}_{(\lnot)}(\sigma^\#)
\coloneqq&~
(\mathit{filter}^\#_{(\lnot)}(T^\#, \varphi^\#), \varphi^\#, p^\#) \\
\end{align*}
\caption{``Boxes'' domain transformers for program state}
\label{fig:boxes}
\end{figure}

Suppose we have some abstract domain over training sets $\mathcal{L}_\mathcal{T}$,
some abstract domain over our predicates (and null value) $\mathcal{L}_{\Phi \cup \{\bot\}}$,
and some abstract domain over our posterior distributions $\mathcal{L}_D$.
Our ``boxes'' abstract domain over states
$\mathcal{L} = (\mathcal{L}_\mathcal{T}, \mathcal{L}_{\Phi \cup \{\bot\}}, \mathcal{L}_D)$
will implement the necessary operations described prior (in the obvious way),
given in Figure~\ref{fig:boxes}.
Of course, Figure~\ref{fig:boxes} mostly deligates responsibilities
to functions over its constituent domains.
However, these functions require some interactions between the domains
(instead of being nicely encapsulated within each, individually).
Specifically, we now require:
\begin{itemize}
    \item $\mathcal{L}_\mathcal{T}$ must implement
        $\lambda T^\# \ldotp T^\# \sqcap
        \alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) = 0\})$
        and
        $\lambda T^\# \ldotp T^\# \sqcap
        \alpha(\{T \in \mathcal{T} : \mathit{impurity}(T) \neq 0\})$.
    \item $\mathcal{L}_{\Phi \cup \{\bot\}}$ must implement
        $\lambda \varphi^\# \ldotp \varphi^\# \sqcap
        \alpha(\{\varphi \in \Phi : x \models \varphi\})$
        and
        $\lambda \varphi^\# \ldotp \varphi^\# \sqcap
        \alpha(\{\varphi \in \Phi : x \not\models \varphi\})$.
    \item Joint knowledge of $\mathcal{L}_\mathcal{T}$ and
        $\mathcal{L}_{\Phi \cup \{\bot\}}$ is needed to implement
        $\mathit{bestsplit}^\#_\Phi : \mathcal{L}_\mathcal{T} \rightarrow
        \mathcal{L}_{\Phi \cup \{\bot\}}$ and
        $\mathit{filter}^\#_{(\lnot)} :
        \mathcal{L}_\mathcal{T} \times \mathcal{L}_{\Phi\cup\{\bot\}}
        \rightarrow \mathcal{L}_\mathcal{T}$.
    \item Joint knowledge of $\mathcal{L}_\mathcal{T}$ and $\mathcal{L}_D$
        is needed to implement
        $\mathit{summary}^\# : \mathcal{L}_\mathcal{T} \rightarrow \mathcal{L}_D$.
\end{itemize}
